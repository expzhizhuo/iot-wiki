---
title: 第一章 物联网概述
---

## 1、早期物联网安全问题

从[智能家居](https://www.tuya.com/cn)设备的隐私问题到僵尸网络，甚至是由僵尸网络发起的全球性分布式拒绝服务(DDoS)攻击，今后很长一段时间，物联网安全威胁将成为网络安全的最大威胁之一，物联网安全支出在整个市场上所占比例也将迅速提高。
<a name="WNN0r"></a>

#### 1.物联网设备的系统安全缺陷和隐私风险。

大型零售商出售的网络或智能家居设备，安全漏洞和隐私问题普遍存在。12个不同的物联网设备都被检测到了安全问题，其中包括缺乏数据加密和缺乏加密认证。这其中包括来自不同厂商的智能相机、智能插头以及安全产品，包括iHome、Merckry、Momentum、Oco、Practecol、TP-Link、Vivitar、Wyze和Zmodo。这次安全“体检”给整个物联网行业敲响了警钟。
<a name="RoCS2"></a>

#### 2.酒店[摄像机](https://solution.tuya.com/cn/category/84318?f=wwwnav)偷拍引起了公众的恐慌。

去年国内物联网影响最大的安全事件非酒店偷拍。酒店偷拍事件在过去的两年里不断发生，从单一的旅馆到五星级酒店都无法幸免。对具有隐私洁癖的用户来说，他们自嘲几乎是在酒店露营的时候需要背帐篷。<br />针对个人隐私保护日益增长的需求，各大厂商和初创企业都在采取行动。市场推出了“偷拍侦测”功能，但APP端检测的缺点之一就是智能探测与局域网(WiFi)段的摄像头，对独立的网络摄像机和离线摄像机无能为力，无法做到100%可靠，充其量也只能是一种辅助措施，消费者需要对此有足够的清醒认识，需要时人肉搜索+超轻双人帐篷仍然是终极方案。
<a name="pvZXd"></a>

#### 3.震惊全美的Ring智能门铃和安全监视头部丑闻。

除旅馆外，家里的监视摄像机也不省心，它暴露了安全漏洞，黑客可以监视用户的家庭，同时也会暴露用户的WiFi密码。很多用户抱怨他们的私生活被黑客们发到了网络上，甚至有黑客通过摄像机向他们的婴儿问好。
<a name="ERQOz"></a>

#### 4.安全隐患反复出现，智能门锁遭遇安全危机。

攻击者可以利用[智能锁](https://solution.tuya.com/cn/category/206001?f=wwwnav)漏洞来远程开门或进入住宅。<br />在国内2019年智能门锁品牌的市场规模有望突破200亿元(是的，你没有看错，一个小小的智能门锁价值比全国信息安全市场的半壁江山)。尽管年初央视曝光了“小黑盒”，APP远程控制漏洞，但国内智能门锁硬件、软件、云等各攻击面的安全问题却没有得到更多用户的关注。有关安全发展、试验检测(包括挖掘白帽等)，技术标准和规范相对滞后。
<a name="AHddf"></a>

#### 5.200万台物联网摄像机“裸奔”

网络摄像机是智慧城市蓬勃发展的重要组成部分，其安全问题的严峻程度也日益突出。<br />2019年4月，据安全研究人员透露，可能是目前为止最严重的物联网摄像机安全漏洞，有200多万个监控摄像头受到影响。<br />这些产品都是由一家国内厂商开发的P2P通信组件iLnkP2P。这个组件包含两个漏洞，可以让远程黑客发现和接管设备内的易损性摄像头，并监控其拥有者。<br />2020年7月，某物联网摄像机制造商在其网络摄像机上发现了一个允许远程攻击者访问其视频源的漏洞。当年九月份，有多达800,000台IP监控摄像机受到了零日漏洞攻击，这一漏洞可以让黑客访问监控摄像头，监控并处理视频源或者植入恶意软件。

<a name="xDwWW"></a>

## 2、物联网系统框架

<a name="HGCdP"></a>

### 1.一些常见的IOT跨开发框架

Eclipse Kura : https://www.eclipse.org/kura/<br />The Physical Web : https://google.github.io/physical-web/<br />IBM Bluemix : 现在为IBM Cloud : https://www.ibm.com/cloud/<br />Lelylan : https://github.com/lelylan<br />Thing Speak : https://thingspeak.com<br />Bug Labs : https://buglabs.me/<br />The thing system : http://thethingsystem.com/<br />Open Remote : https://openremote.io/<br />Open HAB : https://www.openhab.org/<br />Eclipse IOT : https://iot.eclipse.org/<br />Node-Red : https://nodered.org/<br />Flogo : https://www.flogo.io/<br />Kaaa IOT ： https://www.kaaproject.org/<br />Macchina.io : https://Macchina.io/<br />Zetta : https://zettajs.org/<br />CE Predix : https://www.predix.io/<br />DeviceHive : https://devicehive.com/<br />Distributed Services Architecture : http://iot-dsa.org<br />Open Connectivity Foundation : https://openconnectivity.org/

<a name="FCYaT"></a>

### 2.常见的协议

<a name="OVHYc"></a>

###### 1.AMQP

AMQP 是 Advanced Message Queuing Protocol 的缩写，是一种开放标准协议，用于更多面向消息的中间件。因此，无论使用何种消息代理或平台，它都支持系统之间的消息传递互操作性。它提供安全性和互操作性以及可靠性，即使在远距离或在较差的网络上也是如此。它支持通信，即使系统不能同时可用。

<a name="f7iZK"></a>

###### 2.蓝牙和BLE

蓝牙是一种使用短波长、超高频无线电波的短距离无线技术。它最常用于音频流，但它也已成为无线和连接设备的重要推动者。因此，这种低功耗、低范围的连接选项是个人区域网络和物联网部署的首选。

另一种选择是低功耗蓝牙，称为蓝牙 LE 或 BLE，它是针对物联网连接进行优化的新版本。正如其名，BLE 比标准蓝牙消耗更少的功率，这使得它在许多用例中特别有吸引力，例如消费者端的健康和健身追踪器以及智能家居设备以及商业端的店内导航。

<a name="Nm34w"></a>

###### 3.蜂窝

蜂窝是可用于物联网应用的最广泛可用和众所周知的选项之一，它是通信范围更远的部署的最佳选项之一。尽管 2G 和 3G 传统蜂窝标准现在正在逐步淘汰，但电信公司正在迅速扩大新高速标准的覆盖范围——即 4G/LTE 和 5G。蜂窝提供高带宽和可靠的通信。它能够发送大量数据，这是许多物联网部署的重要能力。然而，这些功能是有代价的：比其他选项更高的成本和功耗。

<a name="ZRScc"></a>

###### 4.CoAP

互联网工程任务组约束 RESTful 环境工作组于 2013 年推出了 CoAP，用于约束应用协议，将其设计为与基于 HTTP 的物联网系统一起使用。 CoAP 依靠用户数据报协议来建立安全通信并实现多点之间的数据传输。 CoAP 通常用于机器对机器 (M2M) 应用程序，即使存在低带宽、低可用性和/或低能耗设备，CoAP 也能让受限设备加入物联网环境。

<a name="Tfsvm"></a>

###### 5.DDS

Object Management Group (OMG) 为实时系统开发了数据分发服务。 OMG 将 DDS 描述为“以数据为中心的连接的中间件协议和 API 标准”，解释说“它将系统的组件集成在一起，提供低延迟数据连接、极高的可靠性和可扩展的架构，业务和任务关键型物联网应用程序需要。”此 M2M 标准使用发布-订阅模式实现高性能和高度可扩展的实时数据交换。

<a name="CXBQM"></a>

###### 6.LoRa 和 LoRaWAN

LoRa，就长距离而言，是一种非蜂窝无线技术，顾名思义，它提供了长距离通信能力。它具有低功耗和安全数据传输功能，适用于 M2M 应用程序和物联网部署。它是一项专有技术，现在是 Semtech 射频平台的一部分。 Semtech 是其创始成员的 LoRa 联盟现在是 LoRa 技术的管理机构。 LoRa 联盟还设计并现在维护 LoRaWAN，这是一种基于云的开放协议，使物联网设备能够与 LoRa 通信。

<a name="R9AFW"></a>

###### 7.LWM2M

OMA SpecWorks 将其轻量级 M2M (LWM2M) 描述为“为传感器网络和 M2M 环境需求而设计的设备管理协议”。该通信协议专为物联网环境和其他 M2M 应用中的远程设备管理和遥测而设计；因此，对于处理和存储能力有限的低功耗设备来说，这是一个不错的选择。

<a name="Ywc7X"></a>

###### 8.MQTT

它于 1999 年开发，最初称为消息队列遥测传输，现在只是 MQTT。此协议中不再有任何消息队列。 MQTT 使用发布-订阅架构来启用 M2M 通信。其简单的消息传递协议适用于受限设备，并支持多个设备之间的通信。它旨在在低带宽情况下工作，例如用于不可靠网络上的传感器和移动设备。该功能使其成为连接具有小代码占用空间的设备以及由于带宽限制或不可靠连接而具有不同延迟水平的无线网络的普遍首选选项。 MQTT 最初是一个专有协议，现在是连接物联网和工业物联网设备的领先开源协议。

<a name="e1ZzQ"></a>

###### 9.无线网络

鉴于其在家庭、商业和工业建筑中的普遍存在，Wi-Fi 是一种常用的物联网协议。它提供快速的数据传输，并且能够处理大量数据。 Wi-Fi 特别适合中短距离的 LAN 环境。此外，Wi-Fi 的多种标准——在家庭和一些企业中最常见的是 802.11n——为技术人员提供了部署选择。但是，许多 Wi-Fi 标准（包括家庭中常用的标准）对于某些物联网用例来说过于耗电，尤其是低功耗/电池供电的设备。这限制了 Wi-Fi 作为某些部署的选项。此外，Wi-Fi 的低范围和低可扩展性也限制了其在许多物联网部署中使用的可行性。

<a name="n1uwa"></a>

###### 10.XMPP

可以追溯到 2000 年代初，当时 Jabber 开源社区首次设计了可扩展消息传递和存在协议用于实时人与人之间的通信，XMPP 现在用于轻量级中间件中的 M2M 通信和路由 XML 数据。 XMPP 支持在网络上的多个实体之间实时交换结构化但可扩展的数据，它最常用于面向消费者的物联网部署，例如智能设备。它是 XMPP 标准基金会支持的开源协议。

<a name="QRFoA"></a>

###### 11.Zigbee

Zigbee 是一种网状网络协议，专为楼宇和家庭自动化应用而设计，是物联网环境中最流行的网状协议之一。 Zigbee 是一种短距离和低功耗协议，可用于在多个设备上扩展通信。它的范围比 BLE 长，但数据速率比 BLE 低。它由 Zigbee 联盟监督，提供灵活、自组织的网格、超低功耗和应用程序库。

<a name="b58o0"></a>

###### 12.Z波

另一个专有选项 Z-Wave 是一种基于低功耗射频技术的无线网状网络通信协议。与蓝牙和 Wi-Fi 一样，Z-Wave 允许智能设备通过加密进行通信，从而为物联网部署提供一定程度的安全性。它通常用于家庭自动化产品和安全系统，以及商业应用，例如能源管理技术。它在美国以 908.42 MHz 无线电频率运行；虽然，它的频率因国家而异。 Z-Wave 得到 Z-Wave 联盟的支持，该联盟是一个成员联盟，专注于扩展使用 Z-Wave 的设备的技术和互操作性。

为了评估的物联网上某个设备或通信协议的安全性，还需要使用一些硬件工具

<a name="YXDTQ"></a>

## 3、物联网存在安全的原因

物联网设备较为复杂，可能多数产品都存在安全问题，如果要挖掘和如何开发避免这些漏洞，就需要深入挖掘产品开发的生命周期，有些问题是在设备构建过程中出现的。

<a name="r6GxV"></a>

### 1.开发人员缺乏安全意识

智能设备的开发人员可能不是很了解IOT设备可能存在的安全漏洞，在某大型项目里，开发人员过于忙碌，最好定期召开会议商议如何确保安全性。

<a name="OGkQk"></a>

### 2.使用不安全的开发框架和第三方库


---

<a name="Dt7Cp"></a>

# 第二章 物联网渗透测试

<a name="Mz2pw"></a>

### 2.1 什么是物联网渗透

物联网渗透测试是指对物联网设备的各个组件进行评估和攻击，发现其问题，为改善设备安全性提出建议<br />与传统渗透测试不同，因为物联网设计不同的组件，所以在物联网渗透测试中，每一个组件都需要要测试。<br />物联网渗透测试方法概览-如图：<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/26692716/1654949435354-9d07c459-3fbe-4d39-891a-c0e3a2d6b179.jpeg)<br />了解测试范围，限制条件，环境要求等 → 沟通客户采取那种方式测试（黑、白、灰盒）→  需告知客户准备多台设备 → 探测设备的全部攻击面，然后挖掘漏洞并进行分析利用 →  深度技术报告<br />注：如在测试过程中，存在高危漏洞，可先和客户沟通，以保证高危漏洞的及时修复和防护。

<a name="ntQFH"></a>

### 2.2 攻击面映射

攻击映射是指：在物联网设备上找出攻击者可能会利用的每一个攻击点。<br />这是物联网渗透测试第一步，同样也是最重要的一步。<br />这一步会从测试人员的角度为整个产品创建一个架构图。<br />攻击面映射可以帮助测试人员了解产品架构，同时按优先次序对产品实施的各种测试工作。

<a name="QddTs"></a>

### 2.3 如何实施攻击面映射

在拿到被设备后，首先充分了解该设备，掌握最全面的信息。<br />记录下设备所用的各个组件、CPU架构、通信协议、移动应用程序详情、固件升级进程、硬件接口、分布媒体支持以及其他能够找到的所有信息。<br />对于物联网产品，可以将其整体架构分为三类组件：<br />1）嵌入式设备<br />2）固件、软件和应用程序<br />3）无线电通信<br />通过分析物联网组件来进行供给面映射，目的是为每一类组件功能和安全隐患分类。

<a name="eJfSF"></a>

#### 2.3.1 嵌入式设备

嵌入式设备是打开所有物联网设备的架构钥匙，也是物联网中的一个“物”。<br />根据用户使用情况，物联网产品中嵌入式设备有各种不同的用途。<br />可以是物联网设备中的一个集线器，也可以是收集物理环境数据的传感器，还可以是用来显示数据或执行用户的命令。<br />物联网中的"物"是可以用来收集、检测、分析数据并执行操作的硬件设备。<br />智能家具-举例：智能家居物联网产品是由很多设备构成的，包括智能网关或集线器、只能灯、智能开关、和其他链接设备。<br />虽然听起来可能有些不同，但是测试方法是一样的，这些设备几乎都会保存敏感信息，一旦设备被破解，就会造成极大的危险。
<a name="HevlF"></a>

##### 嵌入式设备中发现的一些漏洞：

Ⅰ、串行端口暴漏<br />Ⅱ、在串行端口上使用不安全的身份认证机制<br />Ⅲ、通过JTAG或闪存芯片进行固件转存<br />Ⅳ、基于外部媒体的攻击<br />Ⅴ、能量分析和测信道攻击
<a name="wy8jb"></a>

##### 为准确判断设备的安全性，应考虑以下几点：

Ⅰ、设备有哪些功能<br />Ⅱ、设备有哪些信息可以被访问<br />注：在搞清楚以上问题的基础上，才能确切的预估安全问题及影响

<a name="oHJO9"></a>

#### 2.3.2 固件、软件和应用程序

了解完硬件后，下一步需要研究的组件部分是物联网设备的软件部分，包括在设备上运行的固件、用来控制设备的app、与设备链接的云组件等。<br />利用这些组件可以把传统的渗透测试经验应用到物联网生态系统上。<br />根据所测试组件的不同，需要使用不同的工具集和技术。
<a name="VOJ76"></a>

##### 关于智能家具，关于组件部分，可以分为一下集中：

Ⅰ、移动app<br />Ⅱ、基于web的仪表盘<br />Ⅲ、不安全的网络接口<br />Ⅳ、固件
<a name="InTxD"></a>

##### 这些组件也有很多漏洞，例如：

<a name="gg2PF"></a>

###### Ⅰ、固件

      - 固件可被篡改
      - 不安全的签名和完整性验证
      - 固件里的硬编码铭感数据--api密钥、密码、暂存url等
      - 私钥证书
      - 能够通过固件了解设备的全部功能
      - 从固件提取文件系统
      - 带有已知漏洞的过期组件

<a name="D7puo"></a>

###### Ⅱ、移动app

      - 逆向工程移动app
      - 暂存移动app的源代码
      - 不安全的身份验证和授权核查
      - 业务逻辑缺陷
      - 旁路信道数据泄露
      - 运行时操纵攻击
      - 不安全的网络通信
      - 旧的第三方库和软件开发包（Software Development Kit,SDK）

<a name="gjjR5"></a>

###### Ⅲ、web应用程序

      - 客户端漏洞注入
      - 不安全的直接对象引用
      - 不安全的身份验证和授权
      - 铭感信息泄露
      - 业务逻辑缺陷
      - 跨站请求伪造
      - 跨站脚本攻击

<a name="xUQya"></a>

#### 2.3.3 无线电通信

无线电通信为各种设备之间的相互通信提供了途径，无线通信也可以成为渗透测试人员查找IOT设备漏洞的切入点。<br />IOT设备常用的无线电通信协议包括蜂窝数据（cellular）、wifi、BLE、ZigBee<br />、Wave、6LoWPAN、LoRa	等。<br />可以根据设备使用的通信协议，使用专门的硬件来进行无线电分析。（在进行评估的时候，应列出所有使用的软硬件设备，方便进行对无线电安全性进行评估）

<a name="tIEpo"></a>

##### 无线电通信的三大类别：

         - 软件定义的无线电（Software Defined Radio , SDK）
         - ZigBee
         - BLE

<a name="X9Ejg"></a>

##### 不同的无线电组件，其漏洞的种类也不同，如无线电和媒介中发现的一些漏洞：

         - 中间人攻击
         - 重放攻击
         - 不安全的循环沉余校验验证
         - 阻塞攻击
         - 拒绝服务
         - 未加密
         - 从无线电数据包中提取铭感信息
         - 实时无线点通信拦截和篡改

<a name="QXdlO"></a>

##### 为无线电通信创建攻击面映射图，应注意：

         - 每个组件的作用
         - 那个组件会启动身份验证和配对机制
         - 配对机制是什么样的
         - 每个组件可以同时处理几个设备
         - 设备在那个频率上操作
         - 每个组件使用的那个协议，是定制协议还是专用协议
         - 是否有类似的设备在相同的频率范围内进行操作

<a name="GirXp"></a>

#### 2.3.4 创建攻击面映射图

<a name="R3oBD"></a>

##### 2.3.4.1 创建攻击面映射图的步骤

IOT设备创建攻击面的操作步骤：

      - 列出目标产品的所有组件
      - 制作框架图
      - 标注组件及组件间的通信流量
      - 确定每一个组件的攻击向量以及使用的通信信道或协议
      - 根据重要性对攻击向量进行分类/分级

注：在fccid.io等平台上，输入IOT设备的FCC ID 就可以搜索到大量的资料。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/26692716/1655207442988-b1998eee-7a32-45b9-bfee-d0a452506b41.jpeg)

<a name="UUHDR"></a>

##### 2.3.4.1 绘制组件关系图

供给面映射图 例子：<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/26692716/1655207867755-48ffa453-7386-419d-91f2-a66d2faed790.jpeg)<br />注：详细到每一个协议是干嘛的，处理器上用的什么芯片，每间隔几分钟通信一次，越详细越好，包括软硬件，等等

基于所获取的所有信息，可以制定表格，列出各个组件的所有测试内容和利用计划，包括一个详细的说明（说明要做到具体的测试、如果攻击会有哪些结果），表格越详细越好， 测试的效率就会越高。

还可以利用一些资源：包括：

      - 物联网渗透测试指导书
      - OWASP发布的嵌入式黑客指南
      - OWASP物联网供给面

<a name="WiiCX"></a>

### 2.4 构建渗透测试

物联网渗透测试的完整过程：

         - 客户参与和初步探讨
         - 更多的技术探讨和信息通报
         - 攻击者模拟利用
         - 补救措施
         - 重新评估

<a name="A6owI"></a>

#### 2.4.1 客户参与和初步探讨

首先要进行初步讨论，还要和技术小组讨论，看是否有了解相关设备的技术人员，以及设备是否满足测试的基本需求，包括可用的资源和时间等。<br />研讨中涉及的几个问题：

      -  测试的预期效果是什么？
      - 客户想要常规的测试还是需要增加一个专门的研究小组？

注：测试人员必须有专业的素养，应该把客户放在第一位。

<a name="WNM5v"></a>

#### 2.4.2 更多的技术探讨和信息通报

接手后，应尽快研究整个项目，在此之前，需要与客户签订保密协议和必要文件，以便客户与测试人员分享关于产品的技术标准。<br />此外还需要了解客户的开发过程，大多数组件都是需要进行灰盒测试，如果使用黑盒可能会漏掉攻击者不会忽略的细节。

<a name="UOMkF"></a>

#### 2.4.3 攻击者模拟利用

现在到了真正的渗透测试阶段。<br />渗透测试是与其他几个工作同时进行的，每一个小组分配不同的任务，进行有规划的工作，<br />建议成立一个至少由三个人组成的小组，成员应有软件、固件、硬件、无线电专家组成。<br />在完成渗透测试任务后，需要撰写一份内容详细的报告，包含：poc脚本描述，高清视频演示，查找漏洞技术，缺陷复现的步骤，补救措施以及其他有关以确定的漏洞的参考资料。

<a name="EvrBd"></a>

#### 2.4.4 补救措施

在渗透测试结束后，测试人员通过语音、视频、电子邮件等方式为开发人员提供解决方案，指出具体要做哪些修改和修复。

<a name="BUX6G"></a>

#### 2.4.5 重新评估

在客户修复完成后，为保证开发人员打的所有有效且安全，不会造成其他的漏洞，进行二次评估。

---

<a name="JPg77"></a>

# 第三章 硬件分析

设备是所有物联网产品的关键组件之一。<br />开展硬件分析有助于完成一下任务：

         - 从实体物联网中提取固件
         - 获取设备的Root Shell，以获取不受限制的访问
         - 绕过安全保护的限制进行调试
         - 将新固件写入
         - 扩展设备的功能

注：应请客户提供两组或更多组设备（以防止在测试过程中设备损毁，无法进行测试）<br />在测试过程中，一定要万分注意，以免受伤。<br />仔细观察考虑如何打开设备以便于在完成硬件分析后能够重新组装回原样。

<a name="zGWCV"></a>

### 3.1 外观检查

设备分析第一步就是外观检查，从不同角度查看设备的基本概况，包括：

                        - 设备有多少功能纽，有多少个按钮
                        - 外部接口都有什么
                        - 设备的显示类型
                        - 设备的电源和电压要求
                        - 设备是否有证书，以及证书的含义
                        - 设备背面是否有FCC ID 标签
                        - 该设备使用了哪些螺丝
                        - 设备是否与市场上具有类似功能的其他产品
                        - 等等其他
            - 注：应尽可能检查详细，并按照位置分类进行汇总表格，建议在拆分设备的时，进行对拆解步骤录制视频，已防止后续无法复原做应急。

<a name="Hcr2w"></a>

#### 3.3.1 找到输入和输出端口

还需要了解输入和输出（I/O）工作方式，以及I/O端口和其他链接的数量.<br />这也是硬件分析的第一步，完成外观检查，拆解设备，后续并还原，创建第二章的攻击面映射图

<a name="Uw0xE"></a>

#### 3.3.2 内部检查

这也是最重要，也是最小心的一步，打开外壳，可以看到里面的构造，大致分为几个区域，分别嵌入了不同的组件，仔细观察各组件型号、功能、接口、厂家等信息，并根据网络收集信息，汇总为表格，一边后续对设备安全性检查，建议在拆解外壳后，进行对主板拍照留存，所有拆解过程，均有视频录制，以便后续复原。

<a name="zQkAx"></a>

#### 3.3.3 分析数据手册

设备的官网可能没有太多的技术信息，这个时候FCC ID 数据库就派上了用处。<br />设备的原理图，一般都会在FCC ID 数据库中，这也是深入了解设备的必经途径。

<a name="u9JRn"></a>

#### 3.1.4 什么是FCC ID 

美国联邦通信委员会是监管各种无线电通信设备的政府机构（具体详见百度，这里就不详细介绍了）<br />可以通过一些网站查询FCC ID 标签，获取到一些设备相关信息，以便后续开展测试工作。<br />利用FCC ID 查找设备信息

      - 可以登录https://fccid.io网站，输入设备标签的FCC ID 信息，进行查询原理图等更加详细的内容

<a name="yMEjw"></a>

#### 3.1.5 组件封装

详细参考链接：[https://blog.csdn.net/xiaopikadi/article/details/122049666](https://blog.csdn.net/xiaopikadi/article/details/122049666)

<a name="euTwT"></a>

### 3.2 无线电芯片组

设备上另一个重要内容就是各种无线电芯片组，通过查看芯片组信息可以帮助我们快速了解设备的通信方式

---


<a name="TJjCz"></a>

# 第四章 UART 通信

通用异步收发器（UART）是一种串行通信方法，它允许两个不同组件相互通信，而无需时钟。<br />它是目前流行的通信接口之一。

<a name="DXQQf"></a>

### 4.1 串行通信

对于物联网来说，不同组件是需要交互和交换数据，设备组件交换数据有两种方式：串行通信和并行通信。<br />串行通信：在传输介质上一次传输1bit（比特）的传输方式。<br />并行通信：同时传输一组比特，每一个比特使用一条单独的线路及参考线，该参考线一般通常指接地线<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/26692716/1656898088112-ee51b13f-b715-4d74-8ce0-8a84f582cb95.jpeg)

串行通信方式

优点：仅需一根线就可以继续宁数据交换

![](https://cdn.nlark.com/yuque/0/2022/jpeg/26692716/1656898523080-f17c6773-7959-499d-a816-0370fd5471c3.jpeg)

并行通信方式<br />缺点：占用主板更多空间。

相对于嵌入式，串行通信是一种更为常见的通信方式。

例：<br />串行通信信道包括：RS323、通用串行总线、PCI、高清多媒体接口、以太网、串行外设接口、内部集成电路、控制器局域网<br />第一个被使用的串行通信信道是RS232，其传输速率为20bit/s。<br />USB 2.0 传输速率为480Mbit/s。<br />USB 3.0 传输速率为5Gbit/s

<a name="i5bzf"></a>

### 4.2 UART 概述

UART是一种异步串行通信协议。<br />异步通信和同步通信不同，它在两个设备进行通信时没有同步的公共时钟

<a name="Jcxcl"></a>

### 4.3 UART 数据包

数据包由以下几个部分组成：<br />1、起始位：表示传输数据开始。通常是低脉冲（0），可以在逻辑分仪中查看。<br />2、消息：要以八位格式传输的实际消息，如：传输值为A（十六进制-0X41），在消息中被传递围殴0、1、0、0、0、0、0、和1。<br />3、奇偶校验位：根据情况，大多数现实生活中无关紧要，设备都是未使用校验位。奇偶校验位用于通过计算消息中1或0的数量，来执行错误和数据损坏的检查，并根据奇校验和偶校验来表明数据传输是否正确。注：校验位仅用于数据损坏检查和验证，而不用于实际校验。<br />4、停止位：表示结束的标志。通常是高脉冲（1）实现，但也可以由多个高脉冲实现。

大多数设备都是使用8N1配置，此配置代表8个数据位、无验证位、有一个停止位。

逻辑分析仪是一种可以显示数字电路中各种信号的电平的设备。<br />如：Salesa逻辑分析仪、Open Workbench逻辑分析仪等

UART数据包结构-图解<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/26692716/1656988311534-764e9dd0-3dbb-4095-8af0-d91f8af79b17.png#clientId=u2eca4a50-af16-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=258&id=u17c3064d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=1126&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10480&status=done&style=none&taskId=ud99b4a11-0ac7-4c2e-a253-956aeedfddc&title=&width=900.8)

<a name="xdxlr"></a>

### UART 端口类型

端口可以基于软件也可以基于硬件。<br />其主要功能是实现组件之间的通信或为开发人员提供其他功能。


<a name="xkWcu"></a>

### 4.4 波特率

对于无需时钟同步的UART来说，可以引入波特率的概念。<br />波特率：设备之间数据传输的速率或每秒传输的比特数。<br />UART 通信没有时钟线，需提前确定比特率、双方都需知道数据传输速率。<br />整个数据交换中，两个组件需要确定唯一的波特率。

注：确定目标设备的比特率

确定方式：<br />1、连接串行接口时查看输出。<br />2、数据不可读---移志下一个波特率。

大多数波特率遵循标准值：常见的有9600、38400、19200、57600、115200、自定义。<br />也可以使用baudrate.py脚本确定---雷克格·赫夫纳编写。

```python
#!/usr/bin/env python

import sys
import time
import serial
from threading import Thread

class RawInput:
    """Gets a single character from standard input.  Does not echo to the screen."""
    def __init__(self):
        try:
            self.impl = RawInputWindows()
        except ImportError:
            self.impl = RawInputUnix()

    def __call__(self): return self.impl()


class RawInputUnix:
    def __init__(self):
        import tty, sys

    def __call__(self):
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch


class RawInputWindows:
    def __init__(self):
        import msvcrt

    def __call__(self):
        import msvcrt
        return msvcrt.getch()

class Baudrate:

    VERSION = '1.0'
    READ_TIMEOUT = 5
    BAUDRATES = [
#            "1200",
#            "1800",
#            "2400",
#            "4800",
            "9600",
            "38400",
            "19200",
            "57600",
            "115200",
    ]

    UPKEYS = ['u', 'U', 'A']
    DOWNKEYS = ['d', 'D', 'B']

    MIN_CHAR_COUNT = 25
    WHITESPACE = [' ', '\t', '\r', '\n']
    PUNCTUATION = ['.', ',', ':', ';', '?', '!']
    VOWELS = ['a', 'A', 'e', 'E', 'i', 'I', 'o', 'O', 'u', 'U']

    def __init__(self, port=None, threshold=MIN_CHAR_COUNT, timeout=READ_TIMEOUT, name=None, auto=True, verbose=False):
        self.port = port
        self.threshold = threshold
        self.timeout = timeout
        self.name = name
        self.auto_detect = auto
        self.verbose = verbose
        self.index = len(self.BAUDRATES) - 1
        self.valid_characters = []
        self.ctlc = False
        self.thread = None

        self._gen_char_list()

    def _gen_char_list(self):
        c = ' '

        while c <= '~':
            self.valid_characters.append(c)
            c = chr(ord(c) + 1)

        for c in self.WHITESPACE:
            if c not in self.valid_characters:
                self.valid_characters.append(c)

    def _print(self, data):
        if self.verbose:
            sys.stderr.write(data)

    def Open(self):
        self.serial = serial.Serial(self.port, timeout=self.timeout)
        self.NextBaudrate(0)

    def NextBaudrate(self, updn):

        self.index += updn

        if self.index >= len(self.BAUDRATES):
            self.index = 0
        elif self.index < 0:
            self.index = len(self.BAUDRATES) - 1

        sys.stderr.write('\n\n@@@@@@@@@@@@@@@@@@@@@ Baudrate: %s @@@@@@@@@@@@@@@@@@@@@\n\n' % self.BAUDRATES[self.index])

        self.serial.flush()
        self.serial.baudrate = self.BAUDRATES[self.index]
        self.serial.flush()

    def Detect(self):
        count = 0
        whitespace = 0
        punctuation = 0
        vowels = 0
        start_time = 0
        timed_out = False
        clear_counters = False

        if not self.auto_detect:
            self.thread = Thread(None, self.HandleKeypress, None, (self, 1))
            self.thread.start()

        while True:
            if start_time == 0:
                start_time = time.time()

            byte = self.serial.read(1)

            if byte:
                if self.auto_detect and byte in self.valid_characters:
                    if byte in self.WHITESPACE:
                        whitespace += 1
                    elif byte in self.PUNCTUATION:
                        punctuation += 1
                    elif byte in self.VOWELS:
                        vowels += 1

                    count += 1
                else:
                    clear_counters = True

                self._print(byte)

                if count >= self.threshold and whitespace > 0 and punctuation > 0 and vowels > 0:
                    break
                elif (time.time() - start_time) >= self.timeout:
                    timed_out = True
            else:
                timed_out = True

            if timed_out and self.auto_detect:
                start_time = 0
                self.NextBaudrate(-1)
                clear_counters = True
                timed_out = False

            if clear_counters:
                whitespace = 0
                punctuation = 0
                vowels = 0
                count = 0
                clear_counters = False

            if self.ctlc:
                break

        self._print("\n")
        return self.BAUDRATES[self.index]

    def HandleKeypress(self, *args):
        userinput = RawInput()

        while not self.ctlc:
            c = userinput()
            if c in self.UPKEYS:
                self.NextBaudrate(1)
            elif c in self.DOWNKEYS:
                self.NextBaudrate(-1)
            elif c == '\x03':
                self.ctlc = True

    def MinicomConfig(self, name=None):
        success = True

        if name is None:
            name = self.name

        config =  "########################################################################\n"
        config += "# Minicom configuration file - use \"minicom -s\" to change parameters.\n"
        config += "pu port             %s\n" % self.port
        config += "pu baudrate         %s\n" % self.BAUDRATES[self.index]
        config += "pu bits             8\n"
        config += "pu parity           N\n"
        config += "pu stopbits         1\n"
        config += "pu rtscts           No\n"
        config += "########################################################################\n"

        if name is not None and name:
            try:
                open("/etc/minicom/minirc.%s" % name, "w").write(config)
            except Exception, e:
                print "Error saving minicom config file:", str(e)
                success = False

        return (success, config)

    def Close(self):
        self.ctlc = True
        self.serial.close()



if __name__ == '__main__':

    import subprocess
    from getopt import getopt as GetOpt, GetoptError

    def usage():
        baud = Baudrate()

        print ""
        print "Baudrate v%s" % baud.VERSION
        print "Craig Heffner, http://www.devttys0.com"
        print ""
        print "Usage: %s [OPTIONS]" % sys.argv[0]
        print ""
        print "\t-p <serial port>       Specify the serial port to use [/dev/ttyUSB0]"
        print "\t-t <seconds>           Set the timeout period used when switching baudrates in auto detect mode [%d]" % baud.READ_TIMEOUT
        print "\t-c <num>               Set the minimum ASCII character threshold used during auto detect mode [%d]" % baud.MIN_CHAR_COUNT
        print "\t-n <name>              Save the resulting serial configuration as <name> and automatically invoke minicom (implies -a)"
        print "\t-a                     Enable auto detect mode"
        print "\t-b                     Display supported baud rates and exit"
        print "\t-q                     Do not display data read from the serial port"
        print "\t-h                     Display help"
        print ""
        sys.exit(1)

    def main():
        display = False
        verbose = True
        auto = False
        run = False
        threshold = 25
        timeout = 5
        name = None
        port = '/dev/ttyUSB0'

        try:
            (opts, args) = GetOpt(sys.argv[1:], 'p:t:c:n:abqh')
        except GetoptError, e:
            print e
            usage()

        for opt, arg in opts:
            if opt == '-t':
                timeout = int(arg)
            elif opt == '-c':
                threshold = int(arg)
            elif opt == '-p':
                port = arg
            elif opt == '-n':
                name = arg
                auto = True
                run = True
            elif opt == '-a':
                auto = True
            elif opt == '-b':
                display = True
            elif opt == '-q':
                verbose = False
            else:
                usage()

        baud = Baudrate(port, threshold=threshold, timeout=timeout, name=name, verbose=verbose, auto=auto)

        if display:
            print ""
            for rate in baud.BAUDRATES:
                print "\t%s" % rate
            print ""
        else:
            print ""
            print "Starting baudrate detection on %s, turn on your serial device now." % port
            print "Press Ctl+C to quit."
            print ""

            baud.Open()

            try:
                rate = baud.Detect()
                print "\nDetected baudrate: %s" % rate

                if name is None:
                    print "\nSave minicom configuration as: ",
                    name = sys.stdin.readline().strip()
                    print ""

                (ok, config) = baud.MinicomConfig(name)
                if name and name is not None:
                    if ok:
                        if not run:
                            print "Configuration saved. Run minicom now [n/Y]? ",
                            yn = sys.stdin.readline().strip()
                            print ""
                            if yn == "" or yn.lower().startswith('y'):
                                run = True

                        if run:
                            subprocess.call(["minicom", name])
                    else:
                        print config
                else:
                    print config
            except KeyboardInterrupt:
                pass

            baud.Close()

    main()

```

<a name="FoUWe"></a>

### 4.5用于 UART开发的链接

设备分析，主要需要两个组件：1、目标设备  2、可以模拟串行链接以访问终端设备的硬件。<br />首先需识别设备的UART端口位置或UART引脚类型。检查内部组件，找出3~4个相邻引的引脚或管脚，是找到UART引脚的简单方法。<br />确定好引脚后，需确定各个引脚的含义：<br />1、传输（Tx）：将数据从设备传输到另一端<br />2、接收（Rx）：从另一端接收数据至设备<br />3、接地（GND）：接地参考引脚<br />4、电压（VCC）：电压通常（3.3-5V）<br />可以通过万用表找到这些引脚，万用表根据导通测试（GND）或电压差(其余三个引脚)来识别引脚。

<a name="PPxXf"></a>

#### 4.5.1 确定 UART引脚

关闭设备电源，执行导通测试识别接地。<br />1、万用表黑色放在接地处（也可以在任何金属表面或attify badge的gnd)，将红色分别放在四个管脚上，听到哔哔声音，红色为接地线（目标设备可能会有多个接地，此处重点关注UART引脚中的GND）<br />2、万用表调至V-20位置，准备测量电压。黑色探诊接GND上，红色探针分别接触UART的其他引脚（GND除外的其他引脚）。启动设备，恒定高电压的地方就是Vcc引脚。（请每次换引脚都关闭开启设备）<br />3、重启设备，并测量GND和其他引脚的电压，由于初始传数据量大，因此会在初始10-15秒左右电压值有巨大的波动。该引脚就是传输引脚（Tx）。<br />4、接收（Rx）由整个过程电压最低的引脚确定，黑色探针链接至AttifyBadge的GND。除此之外剩下的那个就是Rx探针。


<a name="RmLNB"></a>

#### 4.5.2 AttifyBadge

在物联网渗透测试的工具库中必不可少的工具，它能够与不同的硬件协议一起工作的设备。<br />AttifyBadge是一种多功能工具，能够通过各种通信接口与其他物联网/嵌入式设备进行通信。<br />AttifyBadge使用FTDI芯片，芯片允许AttifyBadge把硬件通信协议转换为系统能理解的语言。<br />AttifyBadge 共有18个引脚，其中十个引脚用于电压（3.3v、5v）和接地引脚，分别为顶部的九个引脚和右下角的一个探针。（D0至D3引脚具有特殊用途）<br />![92d3b041e93108f2e65d4fdd5f6673b.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/26692716/1657075151586-c013471c-0d2d-4aa2-b3c1-6d12c2bcbb97.jpeg#clientId=u81d51352-b6e9-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u63f894d1&margin=%5Bobject%20Object%5D&name=92d3b041e93108f2e65d4fdd5f6673b.jpg&originHeight=1080&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=650689&status=done&style=none&taskId=u27358475-0059-45cb-ae75-fffa0a3e526&title=)

引脚排列：

| 引脚 | UART | SPI  | I²C  | JTAG |
| ---- | ---- | ---- | ---- | ---- |
| D0   | TX   | SCK  | SCK  | TCK  |
| D1   | RX   | MISO | SDA* | TDI  |
| D2   |      | MOSI | SDA* | TDO  |
| D3   |      | CS   |      | TMS  |

注：如果将AttifyBadge链接电脑，需要一根微型usb数据线，仅在win下运行需要下载FTDI驱动程序。<br />验证链接，输入：lsusb 

参考资料：<br />[https://www.secpulse.com/archives/150635.html](https://www.secpulse.com/archives/150635.html)<br />[https://v.qq.com/x/page/s0377soqhwb.html](https://v.qq.com/x/page/s0377soqhwb.html)

<a name="JQdcS"></a>

#### 4.5.3 建立最终链接

链接对应表：

| 被测设备引脚 | Attify Badge 链接点      |
| ------------ | ------------------------ |
| Tx           | D1(D1是Badea的Rx)        |
| Rx           | D0(D0是Badge的Tx)        |
| GND          | GND                      |
| Vcc          | 未来链接（根据具体情况） |


<a name="hnmxK"></a>

#### 4.5.4 确定波特率

使用某些脚本和工具确认设备的波特率。<br />[baudrate.py](https://www.yuque.com/attachments/yuque/0/2022/py/26692716/1657077625044-e653401a-c4bc-414f-9e42-7df0047d3375.py)
<a name="tEUWJ"></a>

#### 4.5.5 设备交互

确定好波特率就能通过UART与设备进行交互。检测到波特率，请按ctrl+c，启动minicom实用程序，然后通过baudrate.py脚本可以实现设备交互，另一个方法：利用screen或minicom等已确认的配置，手动启动实用程序。<br />到处需要两个参数值<br />1、设备的波特率<br />2、Attify Badge使用的COM端口：/dev/tyUSB

启动屏幕：screen<br /> sudo screen /dev/ttyusb0 38400<br />运行此命令，重启设备，查看设备启动时候的调试日志。<br />如在等几秒，让设备完全启动并加载busybox，则设备上将具有完整的未经身份验证的rootshell。<br />获取rootshell后我们将可以进行分析设备的文件备份、修改某些配置等。<br />还可以在https://github.com/attify/attify-badge.git，下载并使用attify工具，更新后项目地址：([https://github.com/attify/attify-badge-tool](https://github.com/attify/attify-badge-tool))

在物联网中，很多实际商用设备都允许对设备进行未经身份验证的权限访问。<br />开展基于UART的设备分析时，需要注意以下事项：

                  - 确保设备来凝结正确。
                  - GND连接到其他GND。
                  - Vcc不连接任何设备。
                  - 正确识别波特率，否则会看到乱码。
                  - 当使用3.3V串行设备连接至5V串行设备或其他电压电平时，请确保使用合适的电压转换器

<a name="OMxeo"></a>

# 第五章 I²C和SPI的设备固件获取

<a name="wNInN"></a>

### 5.1 I²C

1982年，为了让芯片能够与其他组件通信和交换数据，飞利浦公司推出了I²C。<br />它使用了七位地址，数据的最高传输速率是100kbit/s，后来地址提高到了10位，速度提升到400kbit/s。<br />目前I²C和其他组件传输速率可达到3.4Mbit/s/<br />从技术方面看，它是一个多主机协议，I²C采用半双工的传输方式，这意味着它只能在给定的时间点发送和接受。
<a name="tVySP"></a>

### 5.2  为什么不使用SPI或者UART

UART面临的问题：<br />在给定时间内只能完成两个设备之间的通信的局限性。<br />数据包中包含起始位和停止位，增加了需要传输的数据包的总大小，还影响整个传输过程的传输速度。<br />设计初衷是进行远距离通信，因此会使用电缆与外部设备进行交互。

相反，I²C和SIP主要用于与同一电路板上其他外围设备通信。

组件另一个非常流行的传输协议是SPI。SPI的传输速率比I²C快。<br />SPI缺点：<br />它需要三个引脚进行数据传输，一个引脚用于片选/从选。<br />这个引脚实现数据传输协议时，增大了整体所需空间。

<a name="yH5Rg"></a>

### 5.3 串行外设接口SPI

SPI是嵌入式设备的流行的通信协议之一，采用全双工的传输方式，由三根传输线(SCK、MOSI、MISO）以及一个片选/从选信号组成。<br />SPI为主设备和从设备提供全双工的同步串行通信。<br />SPI仅使用一个主设备控制所有从设备，主设备控制所有从设备的时钟信号。

<a name="zqmLs"></a>

### 5.4 了解EEPROM

在使用带电可擦可编程只读存储器（EEPROM）存储器时，SPI和I²C都是常用的协议<br />串行EEPROM通常有八个引脚。

| 引脚名称 | 功能         |
| -------- | ------------ |
| #CS      | 片选         |
| SCK      | 串行数据时钟 |
| MISO     | 串行数据输入 |
| MOSI     | 串行数据输入 |
| GND      | 接地         |
| VCC      | 电源         |
| #WP      | 写保护       |
| #HOLD    | 暂停串行输入 |

![066d32c8e10bc96c0cbdf3bd88b6bdd.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/26692716/1657612617143-18ba9e20-a7b1-4de0-b546-34701ce0674b.jpeg#clientId=u054a7dfa-7dad-4&crop=0&crop=0&crop=1&crop=1&from=drop&height=2987&id=u5778c1ac&margin=%5Bobject%20Object%5D&name=066d32c8e10bc96c0cbdf3bd88b6bdd.jpg&originHeight=1680&originWidth=945&originalType=binary&ratio=1&rotation=90&showTitle=false&size=319787&status=done&style=none&taskId=u55db699e-03cc-415a-93c6-da223817152&title=&width=1680)<br />![13025940c46db60cde83467db2a031e.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/26692716/1657612630929-f4672e5b-fba7-40c5-8810-63a2739bbd00.jpeg#clientId=u054a7dfa-7dad-4&crop=0&crop=0&crop=1&crop=1&from=drop&height=3413&id=uc22fc4c7&margin=%5Bobject%20Object%5D&name=13025940c46db60cde83467db2a031e.jpg&originHeight=1920&originWidth=1080&originalType=binary&ratio=1&rotation=90&showTitle=false&size=425907&status=done&style=none&taskId=ude837298-dda7-4c87-8721-395df1e9464&title=&width=1920)

<a name="BXnM7"></a>

### 5.5 基于I²C的设备分析

分析任何应用步骤：<br />1、先找到手册中显示的组件名称<br />2、在线找到对应的组件

![99b5978765358f4e5c45b266ee1245f.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/26692716/1657613241644-1cadd5cc-f13b-4055-916d-e8dabce17fb9.jpeg#clientId=u054a7dfa-7dad-4&crop=0&crop=0&crop=1&crop=1&from=drop&height=3413&id=u471c590c&margin=%5Bobject%20Object%5D&name=99b5978765358f4e5c45b266ee1245f.jpg&originHeight=1920&originWidth=1080&originalType=binary&ratio=1&rotation=90&showTitle=true&size=163379&status=done&style=none&taskId=uea542158-b647-48a8-b397-c6f3b8b7d12&title=%E4%B8%8E%E4%B8%8B%E8%A1%A8%E5%BC%95%E8%84%9A%E5%AF%B9%E6%8E%A5%E5%9B%BE%E8%A7%A3&width=1920 "与下表引脚对接图解")

| 用户配置地址位 | 基于模型的电源           |
| -------------- | ------------------------ |
| 用户配置地址位 | 写保护（低电平有效状态） |
| 用户配置地址位 | 串行时钟                 |
| 接地           | 串行数据                 |


<a name="q9hM1"></a>

### 5.6 I²C和attify badage的应用连接

将EEPROM连接到attifybadge设备上。<br />可以使用SOIC夹固定，或直接连接，也可直接取下来焊接到能装下EEPROM的适配器上。<br />![b149e54b2cf109b14f4bec16f76afd8.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/26692716/1657614106685-0b7a63c0-ece1-43f8-90d7-be72a1a1ee97.jpeg#clientId=u054a7dfa-7dad-4&crop=0&crop=0.1367&crop=0.7712&crop=1&from=drop&height=2946&id=u5996bfd3&margin=%5Bobject%20Object%5D&name=b149e54b2cf109b14f4bec16f76afd8.jpg&originHeight=1920&originWidth=1080&originalType=binary&ratio=1&rotation=90&showTitle=false&size=258626&status=done&style=none&taskId=u45f79be8-acbd-4a63-bba8-5789fac44f0&title=&width=1657)<br />连接方式：<br />A0、A1、A2、GND与GND相连（接地）。<br />Vcc和WP连接到5V上，因为写保护是低电平有效状态。<br />Attify Badge的D1和D2连接到SDK上。<br />D0连接到I²C SCL时钟上。<br />完成连接后，在看如何使用焦恩实现I²C EEPROM的读写。

<a name="s56Bd"></a>

#### 脚本代码解释

我们采用i2ceeprom.py<br />地址：[https://github.com/devttys0/libmpsse/tree/master/src/examples](https://github.com/devttys0/libmpsse/tree/master/src/examples)

```python
#!/usr/bin/env python

from mpsse import *

SIZE = 0x8000		# Size of EEPROM chip (32 KB)  EEPROM芯片大小(32kb)  
WCMD = "\xA0\x00\x00"	# Write start address command	写入起始地址命令 
RCMD = "\xA1"		# Read command	读取命令  
FOUT = "eeprom.bin"	# Output file	输出文件  

try:
	eeprom = MPSSE(I2C, FOUR_HUNDRED_KHZ)

	print "%s initialized at %dHz (I2C)" % (eeprom.GetDescription(), eeprom.GetClock())

	eeprom.Start()
	eeprom.Write(WCMD)

	if eeprom.GetAck() == ACK:

		eeprom.Start()
		eeprom.Write(RCMD)
	
		if eeprom.GetAck() == ACK:
			data = eeprom.Read(SIZE)
			eeprom.SendNacks()
			eeprom.Read(1)
		else:
			raise Exception("Received read command NACK!")
	else:
		raise Exception("Received write command NACK!")

	eeprom.Stop()
	
	open(FOUT, "wb").write(data)	
	print "Dumped %d bytes to %s" % (len(data), FOUT)
	
	eeprom.Close()
except Exception, e:
	print "MPSSE failure:", e
	
```

如果使用不同的配置和不同速率的I²C EEPROM设备，也需要对脚本进行适当的修改。<br />可以根据实际情况修改前九行参数，然后使用eeprom.Start()函数启动I²C时钟，执行start命令将EEPROM速率初始化为400KHz。（11-16行）<br />想从EEPROM中读取数据，先要检查start()中的ACK值以判断EEPROM是否可用，然后使用data = eeprom.Read(SIZE)发送Read命令，并将EEPROM设置为可读模式。（18-39行）<br />设置全部成功的情况下，设备会从EEPROM开始中读取数据，然后保存到data()中。

设备连接好后，运行i2ceeprom.py脚本，可以看到EEPROM的内容已保存到相应的文件中。<br />可以使用相同的方法写入到I²C芯片。

<a name="pB75c"></a>

#### 分析给定设备上I²C的步骤：

1、打开设备<br />2、识别PCB上的I²C芯片<br />3、识别I²C芯片上的组件号<br />4、在线查找数据手册中的引脚信息<br />5、连接设备<br />6、使用i2ceeprom.py脚本向I²C EPROM中读取或写入数据

<a name="faGLb"></a>

### 5.7 深入了解SPI

SPI设备使用四根线与从设备通信：<br />1、串行时钟通信（SCL）<br />2、主出从入线（Master-Out-Slave-In）<br />3、主入从出线（Master-In-Slave-Out）<br />4、从选线（Slave Select，SS）（低电平，来自主输出）<br />注：SPI的从设备共享SCK，MISO、MOSI引脚，但每一个从设备都有自己独特的从选线（SS）。<br />和I²C不同的是SPI协议只允许一个主设备与多个从设备连接，主设备负责同步时钟信号。<br />SPI传输速率不受限制，这要是比其他协议速率快的原因，因为它是全双工的传输方式。

SPI工作原理：<br />主设备会根据从设备的时钟频率设置通信过程的时钟频率，通常频率可达到几十兆赫兹。<br />SPI中最快的时钟频率是系统主时钟频率的一半，如：主频-32MHz，串行时钟频率最大可到16MHz。<br />要启动通信，主设备需要对应连接从设备的SS线置低电平，要注意的是每一个时钟周期内，都会存在全双工的数据传输。<br />主设备通过MOSI线路向从设备发送数据；从设备通过MISO线路向主设备发送数据。<br />MOSI和MISO线在SCLK的每一个时钟周期传输1比特数据。<br />一般情况下，先发送数据的最高位（MSB），最后发送数据的最低位（LSB）。<br />![6a699251-d5ee-48c3-9d15-939cd26f6f96.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/26692716/1657677570664-0c887240-6c2e-45cc-9ac1-92a75079ade4.jpeg#clientId=ua28f810c-5946-4&crop=0&crop=0&crop=1&crop=1&from=drop&height=3765&id=u62a4b6db&margin=%5Bobject%20Object%5D&name=6a699251-d5ee-48c3-9d15-939cd26f6f96.jpg&originHeight=1920&originWidth=979&originalType=binary&ratio=1&rotation=90&showTitle=true&size=312372&status=done&style=none&taskId=u2f936449-975a-44b4-a5d6-64cb3f604a3&title=SIP%E4%B8%BB%E4%BB%8E%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE&width=1920 "SIP主从设备配置")<br />参考连接：<br />[https://baike.baidu.com/item/SPI/53075243](https://baike.baidu.com/item/SPI/53075243)<br />[https://www.elecfans.com/emb/jiekou/20190522940111.html](https://www.elecfans.com/emb/jiekou/20190522940111.html)<br />[https://blog.csdn.net/u010037269/article/details/123912820](https://blog.csdn.net/u010037269/article/details/123912820)

<a name="N7cUX"></a>

### 5.8 SPI EEPROM读写数据

下载所需脚本：[https://github.com/devttys0/libmpsse/blob/master/src/examples/spiflash.py](https://github.com/devttys0/libmpsse/blob/master/src/examples/spiflash.py)<br />根据实际情况，进行适当修改脚本内容及参数。

```python
#!/usr/bin/env python

from mpsse import *
from time import sleep

class SPIFlash(object):

	WCMD = "\x02"		# Standard SPI flash write command (0x02)
	RCMD = "\x03"		# Standard SPI flash read command (0x03)
	WECMD = "\x06"		# Standard SPI flash write enable command (0x06)
	CECMD = "\xc7"		# Standard SPI flash chip erase command (0xC7)
	IDCMD = "\x9f"		# Standard SPI flash chip ID command (0x9F)

	ID_LENGTH = 3		# Normal SPI chip ID length, in bytes
	ADDRESS_LENGTH = 3	# Normal SPI flash address length (24 bits, aka, 3 bytes)
	BLOCK_SIZE = 256	# SPI block size, writes must be done in multiples of this size
	PP_PERIOD = .025	# Page program time, in seconds

	def __init__(self, speed=FIFTEEN_MHZ):

		# Sanity check on the specified clock speed
		if not speed:
			speed = FIFTEEN_MHZ

		self.flash = MPSSE(SPI0, speed, MSB)
		self.chip = self.flash.GetDescription()
		self.speed = self.flash.GetClock()
		self._init_gpio()

	def _init_gpio(self):
		# Set the GPIOL0 and GPIOL1 pins high for connection to SPI flash WP and HOLD pins.
		self.flash.PinHigh(GPIOL0)
		self.flash.PinHigh(GPIOL1)

	def _addr2str(self, address):
        	addr_str = ""

        	for i in range(0, self.ADDRESS_LENGTH):
        	        addr_str += chr((address >> (i*8)) & 0xFF)

        	return addr_str[::-1]

	def Read(self, count, address=0):
		data = ''

		self.flash.Start()
		self.flash.Write(self.RCMD + self._addr2str(address))
		data = self.flash.Read(count)
		self.flash.Stop()

		return data

	def Write(self, data, address=0):
		count = 0

		while count < len(data):

			self.flash.Start()
        		self.flash.Write(self.WECMD)
        		self.flash.Stop()

			self.flash.Start()
			self.flash.Write(self.WCMD + self._addr2str(address) + data[address:address+self.BLOCK_SIZE])
			self.flash.Stop()

			sleep(self.PP_PERIOD)
			address += self.BLOCK_SIZE
			count += self.BLOCK_SIZE

	def Erase(self):
		self.flash.Start()
		self.flash.Write(self.WECMD)
		self.flash.Stop()

		self.flash.Start()
		self.flash.Write(self.CECMD)
		self.flash.Stop()

	def ChipID(self):
		self.flash.Start()
		self.flash.Write(self.IDCMD)
		chipid = self.flash.Read(self.ID_LENGTH)
		self.flash.Stop()
		return chipid

	def Close(self):
		self.flash.Close()


if __name__ == "__main__":

	import sys
	from getopt import getopt as GetOpt, GetoptError

	def pin_mappings():
		print """
           Common Pin Mappings for 8-pin SPI Flash Chips
--------------------------------------------------------------------
| Description | SPI Flash Pin | FTDI Pin | C232HM Cable Color Code |
--------------------------------------------------------------------
| CS          | 1             | ADBUS3   | Brown                   |
| MISO        | 2             | ADBUS2   | Green                   |
| WP          | 3             | ADBUS4   | Grey                    |
| GND         | 4             | N/A      | Black                   |
| MOSI        | 5             | ADBUS1   | Yellow                  |
| CLK         | 6             | ADBUS0   | Orange                  |
| HOLD        | 7             | ADBUS5   | Purple                  |
| Vcc         | 8             | N/A      | Red                     |
--------------------------------------------------------------------
"""
		sys.exit(0)

	def usage():
		print ""
		print "Usage: %s [OPTIONS]" % sys.argv[0]
		print ""
		print "\t-r, --read=<file>      Read data from the chip to file"
		print "\t-w, --write=<file>     Write data from file to the chip"
		print "\t-s, --size=<int>       Set the size of data to read/write"
		print "\t-a, --address=<int>    Set the starting address for the read/write operation [0]"
		print "\t-f, --frequency=<int>  Set the SPI clock frequency, in hertz [15,000,000]"
		print "\t-i, --id               Read the chip ID"
		print "\t-v, --verify           Verify data that has been read/written"
		print "\t-e, --erase            Erase the entire chip"
		print "\t-p, --pin-mappings     Display a table of SPI flash to FTDI pin mappings"
		print "\t-h, --help             Show help"
		print ""

		sys.exit(1)

	def main():
		fname = None
		freq = None
		action = None
		verify = False
		address = 0
		size = 0
		data = ""

		try:
			opts, args = GetOpt(sys.argv[1:], "f:s:a:r:w:eipvh", ["frequency=", "size=", "address=", "read=", "write=", "id", "erase", "verify", "pin-mappings", "help"])
		except GetoptError, e:
			print e
			usage()

		for opt, arg in opts:
			if opt in ('-f', '--frequency'):
				freq = int(arg)
			elif opt in ('-s', '--size'):
				size = int(arg)
			elif opt in ('-a', '--address'):
				address = int(arg)
			elif opt in ('-r', '--read'):
				action = "read"
				fname = arg
			elif opt in ('-w', '--write'):
				action = "write"
				fname = arg
			elif opt in ('-i', '--id'):
				action = "id"
			elif opt in ('-e', '--erase'):
				action = "erase"
			elif opt in ('-v', '--verify'):
				verify = True
			elif opt in ('-h', '--help'):
				usage()
			elif opt in ('-p', '--pin-mappings'):
				pin_mappings()

		if action is None:
			print "Please specify an action!"
			usage()

		spi = SPIFlash(freq)
		print "%s initialized at %d hertz" % (spi.chip, spi.speed)

		if action == "read":
			if fname is None or not size:
				print "Please specify an output file and read size!"
				usage()

			sys.stdout.write("Reading %d bytes starting at address 0x%X..." % (size, address))
			sys.stdout.flush()
			data = spi.Read(size, address)
			open(fname, 'wb').write(data)
			print "saved to %s." % fname

		elif action == "write":
			if fname is None:
				print "Please specify an input file!"
				usage()

			data = open(fname, 'rb').read()
			if not size:
				size = len(data)

			sys.stdout.write("Writing %d bytes from %s to the chip starting at address 0x%X..." % (size, fname, address))
			sys.stdout.flush()
			spi.Write(data[0:size], address)
			print "done."

		elif action == "id":

			for byte in spi.ChipID():
				print ("%.2X" % ord(byte)),
			print ""

		elif action == "erase":

			data = "\xFF" * size
			sys.stdout.write("Erasing entire chip...")
			sys.stdout.flush()
			spi.Erase()
			print "done."

		if verify and data:
			sys.stdout.write("Verifying...")
			sys.stdout.flush()

			vdata = spi.Read(size, address)
			if vdata == data:
				if data == ("\xFF" * size):
					print "chip is blank."
				elif data == ("\x00" * size):
					print "read all 0x00's."
				else:
					print "reads are identical, verification successful."
			else:
				print "reads are not identical, verification failed."

		spi.Close()

	main()

```

<a name="SlN4Q"></a>

### 5.9 使用SPI和Attify Badge 转储固件

在一个完整的固件设备上，尝试转储固件内容。<br />将设备与attify badge连接，运行apiflash.py脚本，设定足够大的转储大小。<br />sudo python apiflash.py -r wrtnode-dump.bin -s 20000000<br />得到wrtnode-dump.bin后就可以运行固件分析攻工具（Binwalk等），解析整个文件系统。<br />binwalk wrtnode-dump.bin


<a name="Golmj"></a>

# 第六章 JTAG调试分析

JTAG其实不是一个标准的协议，而是一种测试和调试设备上芯片的方法，JTAG使用了一种名为边界扫描的技术。<br />与传统的放法比，这种技术使制造商可以轻松地检测和诊断装配好的PCB。

<a name="YGJqU"></a>

### 6.1 边界扫描

边界扫描是对电路中不同芯片的各引脚进行调试和测试的技术。<br />通过在被测芯片的每一个引脚附近添加一个组件来实现，这个组件称为边界扫描单元。<br />![9b54735774c0ecfcaa0b2f1b5bcdf9ea.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/26692716/1657690486704-ae33fcff-bd6d-4e0c-93d3-89d82e083bb3.jpeg#clientId=udcf3dd87-9264-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u7ff82d01&margin=%5Bobject%20Object%5D&name=9b54735774c0ecfcaa0b2f1b5bcdf9ea.jpg&originHeight=624&originWidth=624&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74025&status=done&style=none&taskId=u1b2df8f8-1917-4fc8-8d54-a716aef9038&title=)<br />注：I/O管脚和每个芯片周边的边界扫描单元。可以访问和检查边界扫描单元的值。<br />还有一个被称为扫描描述语言文件的外部文件，它定义了单一设备上的边界扫描逻辑能力。

<a name="RHoNL"></a>

### 6.2 测试访问口

在JTAG标准中，寄存器被分为两大类， 数据存储器、指令寄存器。<br />边界扫描寄存器即为一种很重要的数据寄存器，边界扫描链可用来观察和控制芯片的输入输出。<br />指令寄存器是用来实现对数据寄存器的控制。<br />TAP是一个通用接口，通过TAP可以访问芯片提供的数据寄存器和指令寄存器。<br />TAP包含5个信号接口：<br />1、TCK：为TAK操作提供一个独立的基本的时钟信号<br />2、TMS：用来控制TAP状态机的转换<br />3、TDI：是JTAG指令和数据的串行输入端。<br />4、TDO：是JTAG指令和数据的串行输出端<br />5、TRST：是JTAG电路的复为输入信号，低电平有效<br />注：TAP控制器共有16中状态。

<a name="lSu4v"></a>

### 6.3 边界扫描器指令

每个支持JTGA调试的芯片必须包含一个指令寄存器。<br />测试过程中，将特定的指令转载到指令寄存器中，用来选择需要执行的测试。<br />JTAG标准IEEE 1149.1 要求的芯片支持基本指令：EXTEST、INTEST、SAMPLE/PRELOAD、BYPASS、HIGHZ等。

测试过程：<br />1、TAP控制器将测试数据应用到TDI引脚上<br />2、BSR（边界扫描器）监视设备的输入，边界扫描单元捕获数据<br />3、数据通过TDI引脚进入设备<br />4、数据通过TDO引脚离开设备<br />5、测试人员可以验证设备输入引脚上的数据，确认都是否正常

<a name="eP54e"></a>

### 6.4 JTAG调试

因为JTAG允许调试目标系统和系统的各个组件，所以对于渗透测试和安全研究院来说非常有用。<br />在使用JTAG进行调试以及与调试器进行集成的时，可以设置断点并分析堆栈寄存器、指令寄存器和寄存器数据。

<a name="aGtGp"></a>

### 6.5 识别JTAG引脚

与UART相比，识别引脚较为困难。<br />只需要查找三个或四个相邻的引脚，然后使用万用表识别各个引脚即可。<br />最常关注的引脚有：TDI、TDO、TMS、TCK。

识别引脚的两种方法：<br />1、使用JTAGulator<br />2、使用带有JTAGEnum的Arduino

参考资料：<br />[http://www.usbjtag.com/](http://www.usbjtag.com/)<br />[https://forum.dd-wrt.com/phpBB2/files/jtag_wg602v3_643.jpg](https://forum.dd-wrt.com/phpBB2/files/jtag_wg602v3_643.jpg)<br />[https://baike.baidu.com/item/JTAG%E6%8E%A5%E5%8F%A3/8854374?fr=aladdin](https://baike.baidu.com/item/JTAG%E6%8E%A5%E5%8F%A3/8854374?fr=aladdin)<br />[https://www.renrendoc.com/paper/161064536.html](https://www.renrendoc.com/paper/161064536.html)<br />[https://www.likecs.com/show-203760272.html](https://www.likecs.com/show-203760272.html)<br />[https://blog.csdn.net/weixin_39633090/article/details/111262103](https://blog.csdn.net/weixin_39633090/article/details/111262103)

<a name="DeIeg"></a>

#### 6.5.1 使用JTAGulator

连接设备<br />参考资料：<br />[https://blog.csdn.net/weixin_42045853/article/details/86523347](https://blog.csdn.net/weixin_42045853/article/details/86523347)<br />[https://www.bilibili.com/read/cv13047230](https://www.bilibili.com/read/cv13047230)<br />[https://www.bilibili.com/video/av847243729?p=2&spm_id_from=pageDriver](https://www.bilibili.com/video/av847243729?p=2&spm_id_from=pageDriver)

<a name="r5kAm"></a>

#### 6.5.2 使用带有JTAGEnum的Arduino

具体不进行阐述，自行百度<br />[https://blog.csdn.net/duping812/article/details/121423985](https://blog.csdn.net/duping812/article/details/121423985)
<a name="d1AFj"></a>

### 6.6 OpenOCD

openocd是一个实用程序，允许开发者使用JTAG对目标设备进行偏上调试。<br />它是一款开源的软件，它与硬件调试器的JTAG端口进行对接。<br />调试JTAG的一些工作：<br />1、调试设备的上的各种芯片<br />2、在程序上设置断点，分析给定时刻寄存器和堆栈的内容<br />3、分析设备上的内存内容<br />4、进行内存编程，闪存数据<br />5、转储固件内容和其他铭感信息

<a name="fzh96"></a>

#### 6.6.1 安装用于JTAG调试的软件

工具有：OpenOCD、GDB-Multiarch、AttifyBadge工具<br />安装OpenOCD：apt install OpenOCD <br />下载AttifyBadge工具：https://github.com/attify/attify-badge

<a name="du6xS"></a>

#### 6.6.2 用于JTAG调试的硬件

JTAG调试和分析会用到一下工具：<br />1、Attify Badge或者其他工具，例如BusPirate、Segger J-Link<br />2、具有JTAG接口的目标设备<br />在连接JTAG之前，需要检查OpenOCD工具是否支持目标设备上的控制器，可以通过查询OpenOCD源代码中提供的目标列进行检查。QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQAAAAAAA<br />应该确保目标列在源代码附带的OpenOCD目标列表中，否则必须为目标设备创建一个手动配置文件。<br />openocd-0.10.0/tcl/target》ls

<a name="lvvUj"></a>

### 6.7 JTAG调试前准备

建立JTAG调试所需的连接。<br />JTAG和Attify Bade的连接信息

| Attify Bade | 功能 | 连接 |
| ----------- | ---- | ---- |
| D0          | TCK  | CLK  |
| D1          | TDI  | TDI  |
| D2          | TDO  | TDO  |
| TMS         | TMS  | TMS  |

连接引脚会根据要分析的目标设备是处理器还是控制器而有所不同。

测试步骤：<br />1、连接设备<br />2、确保attify badge的配置文件（.cfg）和目标设备的配置文件完好。<br />3、对于目标设备的配置文件，可以从opencod自带的配置文件中获取<br />4、运行 sudo openocd -f badge.cfg -f 目标设备.cfg<br />5、从返回数据可以看到一些额外的信息<br />6、在连接显示屏之后，可以使用telent与openocd进行通信<br />openocd通过JTAG连接目标设备，执行telent localhost 444

<a name="MjKRp"></a>

### 6.8 基于JTAG的固件读写

现在可以使用openocd和jtad的远程会话来讲固件写入卫星控制器等操作。

<a name="PjI2Q"></a>

#### 6.8.1 经数据和固件的内容写入设备

为了给设备写一个新的固件内容，需要先检查一下闪存和启动地址，然后在向设备写入新的固件时使用这个地址。（flash banks）执行后返回，前面的为闪存地址，后面的为数据大小<br />将固件写入设备，命令（flash write_image erase 固件.bin 闪存地址）<br />在使用命令（flash banks）查看闪存存储大小

<a name="bmjvz"></a>

#### 6.8.2 从设备中转储数据和固件

如果其他获取固件的方法都失败了，可以将JTAG作为备用方式。<br />dump_image 固件.bin 闪存地址 储存大小

<a name="vWhj3"></a>

#### 6.8.3 从设备中读取数据

使用JTAG工具指定读取内存地址数据，mdw命令<br />示例：mdw 闪存地址+偏移地址转存密码 块数<br />    mdw        0x0800d240                     10  

<a name="vwDje"></a>

#### 6.8.4 使用gdb调试JTAG

用openocd来对目标设备执行JTAG调试，需要启动两个服务：1、服务通过4444端口记性远程连接，这个端口用来和openocd交互的。2、服务通过3333端口和gdb交互，这样就可以调试目标设备上运行的二进制文件。<br />调试步骤：<br />1、连接后，将架构选择设置为合适的，将其端口更改为3333<br />命令：gdb-multiarch -q 二进文件名.elf<br />set architecture arm（架构选择，例如arm）<br />target remote localhost:3333   （更改端口为3333）

设置架构后，就可以使用hbreak、break命令，设置断点。<br />前者用于设置硬件辅助断点，后者用于指令、内存或函数上设置正常断点。<br />在查看二进制文件中的各种函数，使用indo查看函数（info functions）<br />查看函数具体的汇编代码可以使用（disassemble 要查看的函数）<br />设置断点（b 地址）	继续执行（c）<br />可以使用info registers 命令来分析寄存器信息<br />使用x/s明令查看r0和r1的内容（x/s $r0）<br />修改r0寄存器指向的输入密码（set $r0="xiaoli"）

参考链接：<br />[https://blog.csdn.net/itworld123/article/details/124581437](https://blog.csdn.net/itworld123/article/details/124581437)<br />[https://baijiahao.baidu.com/s?id=1728712912672790096&wfr=spider&for=pc](https://baijiahao.baidu.com/s?id=1728712912672790096&wfr=spider&for=pc)


<a name="L3QIX"></a>

# 第七章 固件逆向分析

<a name="X5deL"></a>

### 7.1 固件所需的工具

binwalk、firmware mod kit、firmware analysis toolkit、firmwalker

<a name="LCUQb"></a>

### 7.2 了解固件

固件是一种写入硬件设备的软件，作用是对应用和各项系统功能实施控制。固件中包含底层代码，这些代码能够帮助软件实现对硬件的操作。运行固件的设备称为嵌入式系统，嵌入式系统的硬件资源在存储能力以及内存等方面往往具有诸多限制。举例来说，智能手机、交通信号灯、网联汽车、某些类型的专用计算机、无人机和有线机顶盒都是运行固件的嵌入式设备。<br />下面只重点关注固件的文件系统。<br />嵌入式设备或物联网设备固件中的文件系统可以有不通的类型，这取决于制造商的要求和设备的功能。<br />每一个不同类型的文件系统都有唯一的签名首部，可以帮助我们标识文件系统在整个固件二进制文件中的起始位置。<br />物联网设备的常见文件系统：squashfs、cramfs、jffs2、yaffs2、ext2<br />针对不同的文件系统，会使用不同的压缩方式：zip、lzma、gzip、zlib、arj

参考连接：<br />[http://www.hackdig.com/11/hack-532573.htm](http://www.hackdig.com/11/hack-532573.htm)\<br />[https://javaforall.cn/128690.html](https://javaforall.cn/128690.html)

<a name="KPHOH"></a>

### 7.3 获取固件的二进制文件

访问获取二进制文件的方法包含：<br />1、在线获取设备二进制文件（最常见的方法）。<br />2、直接从设备上提取固件。<br />3、空中嗅探技术。这是在设备上级过程中获取固件二进制文件的另一种常见方式。<br />4、逆向工程。

<a name="kTwJD"></a>

#### 固件提取

获取固件镜像后，最重要的就是从二进镜像中提取文件系统。<br />通常有两种方式：手动方式、自动方式
<a name="FQl4r"></a>

##### 1、手动方式

可以使用 hexdump 命令以hex格式转储二进制固件文件的内容。<br />还可以使用grep命令查找squashfs文件系统种的签名头字节shsq，如果无法搜索到shsq，可以尝试查找lzma、gzip等签名字节。